export const angularList = () => {
    return [
        {
            "name": "<p><strong>Basic</strong></p>",
            "sectionId": 1,
            "noteType": "Angular",
            "topics": [
                {
                    "text": "<p><strong>What is Angular?</strong></p>",
                    "sectionId": 1,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 1,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is a </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">TypeScript-based front-end framework</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> developed by Google for building </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">single-page applications (SPAs)</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. It provides a </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">component-based architecture</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, built-in </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">dependency injection</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">,</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> two-way data binding</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, and </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">powerful RxJS-based state management</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is a</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> full-fledged front-end framework</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> that provides a complete solution for building web applications. It includes built-in support for </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">routing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">forms</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, and</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> HTTP communication</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> through </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">HttpClient</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">offers </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">two-way data binding</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, which automatically synchronizes the model and the view. It uses </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">dependency injection</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> to make services reusable and improve testability. Angular also leverages </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">RxJS </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">for efficient asynchronous data handling and supports </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">TypeScript</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, which enhances maintainability, scalability, and developer productivity.</span></p>"
                },
                {
                    "text": "<p><strong>How is it different from other JavaScript frameworks?</strong></p>",
                    "sectionId": 1,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 2,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is a</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> full-fledged front-end framework</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> that provides a complete solution for building web applications. It includes built-in support for </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">routing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">forms</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, and</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> HTTP communication</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> through </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">HttpClient</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">offers </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">two-way data binding</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, which automatically synchronizes the model and the view. It uses </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">dependency injection</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> to make services reusable and improve testability. Angular also leverages </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">RxJS </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">for efficient asynchronous data handling and supports </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">TypeScript</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, which enhances maintainability, scalability, and developer productivity.</span></p>"
                },
                {
                    "text": "<p><strong>What are the key features of Angular?</strong></p>",
                    "sectionId": 1,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 3,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">offers several key features such as Component-Based Architecture, Two-Way Data Binding, Dependency Injection (DI), powerful Directives, RxJS for Reactive Programming, Built-in Routing, robust Forms Handling, State Management using tools like NgRx, and Cross-Platform Support for building web, mobile, and desktop applications.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">These features make Angular a powerful and scalable framework for building enterprise-level applications efficiently.</span></p>"
                },
                {
                    "text": "<p><strong>If we can create dynamic pages using JavaScript, why do we need Angular?</strong></p>",
                    "sectionId": 1,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 4,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">JavaScript </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">can create dynamic pages, but </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">provides a structured framework for building large-scale, maintainable applications. It offers features like component-based architecture, two-way data binding, dependency injection, routing, and state management, which help manage complexity, improve code reusability, and speed up development â€” especially for enterprise-grade apps.</span></p>"
                },
                {
                    "text": "<p><strong>Explain the differences between AngularJS and Angular.</strong></p>",
                    "sectionId": 1,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 5,
                    "description": "<ol><li><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">AngularJS is based on the </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">MVC (Model-View-Controller)</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> architecture, whereas Angular follows a </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">component-based architecture</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. </span></li><li><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">AngularJS supports </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">JavaScript</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, whereas Angular supports </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">TypeScript</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. </span></li><li><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">AngularJS is </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">not optimized for mobile</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, whereas Angular is </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">mobile-friendly</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></li><li><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">AngularJS has been </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">discontinued</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, whereas Angular is </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">actively maintained by Google</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></li></ol>"
                },
                {
                    "text": "<p><strong>What is Angular Application load flow?</strong></p>",
                    "sectionId": 1,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 6,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">The browser loads </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">index.html</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, which usually contains a root element (like </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">&lt;app-root&gt;</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">). Then </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">main.ts</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> executes. This is the entry point (the first TypeScript file that runs), and its job is to bootstrap the Angular application.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Earlier, Angular used </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">platformBrowserDynamic().bootstrapModule(AppModule)</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> for NgModules. But after the introduction of standalone components, it now uses </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">bootstrapApplication()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> to bootstrap a component directly.</span></p></br></br><pre data-language=\"plain\">\nmain.ts\n\nimport { bootstrapApplication } from &#39;@angular/platform-browser&#39;;\nimport { appConfig } from &#39;./app/app.config&#39;;\nimport { App } from &#39;./app/app&#39;;\nbootstrapApplication(App, appConfig)\n  .catch((err) =&gt; console.error(err));\n</pre></br><p>Next, Angular initializes AppComponent, whose selector (&lt;app-root&gt;) matches the element in index.html.</p><p>For dependency injection setup, bootstrapApplication() also accepts providers such as HttpClient, Router, etc.</p></br></br><pre data-language=\"plain\">\napp.config.ts\n\nimport { ApplicationConfig, provideBrowserGlobalErrorListeners, provideZoneChangeDetection } from &#39;@angular/core&#39;;\nimport { provideRouter } from &#39;@angular/router&#39;;\nimport { routes } from &#39;./app.routes&#39;;\nimport { provideHttpClient } from &#39;@angular/common/http&#39;;\nexport const appConfig: ApplicationConfig = {\n  providers: [\n    provideBrowserGlobalErrorListeners(),\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideHttpClient(),\n    provideRouter(routes)\n  ]\n};\n</pre></br><p>Angular then builds the component tree starting from the root component, runs change detection, and updates the DOM.</p>"
                }
            ],
            "subSections": []
        },
        {
            "name": "<p><strong>Angular CLI</strong></p>",
            "sectionId": 2,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Module</strong></p>",
            "sectionId": 3,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Templates</strong></p>",
            "sectionId": 4,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>ng-template and ng-container</strong></p>",
            "sectionId": 5,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Directives</strong></p>",
            "sectionId": 6,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Service and Injectable</strong></p>",
            "sectionId": 7,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Angular lifecycle hooks</strong></p>",
            "sectionId": 8,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Data Binding</strong></p>",
            "sectionId": 9,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Pipes</strong></p>",
            "sectionId": 10,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Routing</strong></p>",
            "sectionId": 11,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Forms</strong></p>",
            "sectionId": 12,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Zone.js, NgZone and Change Detection</strong></p>",
            "sectionId": 13,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Guards</strong></p>",
            "sectionId": 14,
            "noteType": "Angular",
            "topics": [
                {
                    "text": "<p><strong>What are Angular Guards?</strong></p>",
                    "sectionId": 14,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 27,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Route Guards</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> are used to control access to routes based on conditions (e.g., authentication, permissions).</span></p>"
                },
                {
                    "text": "<p><strong>Explain the types of route guards.</strong></p>",
                    "sectionId": 14,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 28,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">1. CanActivate:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanActivate </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is used to prevent unauthorized access to a route.</span></p></br><p><strong>2.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanActivateChild:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanActivateChild </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is used to </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">guard child routes</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> of a particular route.</span></p></br><p><strong>3.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanDeactivate:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanDeactivate </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is a</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> route guard</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> used to prevent navigation away from a component.</span></p></br><p><strong>4.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Resolve</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">: Fetches data before loading a route.</span></p></br><p><strong>5.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanLoad:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanLoad </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is used to</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">prevent loading a module unless conditions are met (used with lazy loading).</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular deprecated CanLoad in favor of the more powerful and flexible </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">CanMatch </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">guard starting in </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Angular v14+</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, especially for </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">standalone components</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> and </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">lazy-loaded routes</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p>"
                },
                {
                    "text": "<p><strong>Can you explain how to implement authentication guards in Angular?</strong></p>",
                    "sectionId": 14,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 29,
                    "description": "<p>Authentication guards are implemented using the <code>CanActivate</code> interface, which controls access to routes based on conditions such as whether the user is logged in.</p>"
                }
            ],
            "subSections": []
        },
        {
            "name": "<p><strong>Component Communication</strong></p>",
            "sectionId": 15,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>ViewChild and ContentChild</strong></p>",
            "sectionId": 16,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Loading</strong></p>",
            "sectionId": 17,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Performance Optimization</strong></p>",
            "sectionId": 18,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Interceptor</strong></p>",
            "sectionId": 19,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Compiler</strong></p>",
            "sectionId": 20,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>angular.json file</strong></p>",
            "sectionId": 21,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Tokens</strong></p>",
            "sectionId": 22,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Challenges Faced in Angular Project</strong></p>",
            "sectionId": 23,
            "noteType": "Angular",
            "topics": [],
            "subSections": []
        },
        {
            "name": "<p><strong>Unit Testing</strong></p>",
            "sectionId": 24,
            "noteType": "Angular",
            "topics": [
                {
                    "text": "<p><strong>What is Unit Testing in Angular, and why is it important?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 7,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Unit testing in Angular is the process of testing individual components, services, or functions in isolation to ensure they work correctly and make the application more reliable and maintainable.</span></p>"
                },
                {
                    "text": "<p><strong>What testing frameworks are commonly used with Angular (Jasmine, Karma, Jest)?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 8,
                    "description": "<p class=\"ql-align-justify\"><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jasmine</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a testing framework, </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Karma</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a test runner (executes tests in browsers), and </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jest</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is an alternative framework+runner offering faster, simpler testing.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">In short: </span><em style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jasmine + Karma work together</em><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, while </span><em style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jest alone can replace both</em><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p>"
                },
                {
                    "text": "<p><strong>What is the difference between unit testing and end-to-end testing?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 9,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Unit testing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> checks individual components/services in isolation, while </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">end-to-end testing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> validates the entire application flow from the userâ€™s perspective.</span></p>"
                },
                {
                    "text": "<p><strong>What is the default test runner in Angular projects created with Angular CLI?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 10,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">The default test runner in Angular projects created with Angular CLI is </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Karma</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p>"
                },
                {
                    "text": "<p><strong>How do you create a new Angular component test file using CLI?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 11,
                    "description": "<p class=\"ql-align-justify\"><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">You can create a new Angular component with its spec (test) file using:</span></p><pre data-language=\"plain\">\nng generate component component-name\n</pre><p class=\"ql-align-justify\"></p><p class=\"ql-align-justify\"><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">ðŸ‘‰ The CLI automatically generates the </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">.spec.ts</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> test file.</span></p></br>"
                },
                {
                    "text": "<p><strong>What is â€˜describeâ€™ in jasmine in Unit Testing?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 12,
                    "description": ""
                },
                {
                    "text": "<p><strong>What is beforeEach in Jasmine?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 13,
                    "description": ""
                },
                {
                    "text": "<p><strong>What is TestBed in Angular Unit Testing?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 14,
                    "description": "<p><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">TestBed</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">is the </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">primary Angular testing utility</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> that creates a </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">simulated Angular environment</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> for unit testing.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">It allows us to test components, directives, pipes, and services </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">with Angularâ€™s dependency injection, change detection, and templates</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p class=\"ql-align-justify\"><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">1. </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">TestBed </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">Configures a testing module</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> (like a mini </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">NgModule</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">):</span></p><pre data-language=\"plain\">\n\n  TestBed.configureTestingModule({\n  \tdeclarations: [MyComponent],\n  \tproviders: [MyService],\n \timports: [FormsModule, HttpClientTestingModule]\n   });\n</pre><p class=\"ql-align-justify\"></p><p class=\"ql-align-justify\"><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">2.</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> TestBed creates Components for testing:</span></p><pre data-language=\"plain\">\n\n   const fixture = TestBed.createComponent(MyComponent);\n   const component = fixture.componentInstance;\n   fixture.detectChanges(); // runs ngOnInit + bindings\n</pre></br><p>3. TestBed is used to Inject Services:</p><pre data-language=\"plain\">\n      \n    const service = TestBed.inject(MyService);\n\n</pre><p><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">4. Run Change Detection:</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> Updates the DOM after changing component properties.</span></p>"
                },
                {
                    "text": "<p><strong>What is â€˜itâ€™ in jasmine in Unit Testing?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 15,
                    "description": ""
                },
                {
                    "text": "<p><strong>What is â€˜expectâ€™ in Jasmin?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 16,
                    "description": ""
                },
                {
                    "text": "<p><strong>Can you describe some matchers?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 17,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">In Angular unit testing, a matcher function compares the actual result with the expected result.</span></p></br><p><strong>1.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">toBeTruthy:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">.toBeTruthy()</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">checks that a value is not </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">false</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">0</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">&#39;&#39;</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">null</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">undefined</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, or </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">NaN</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>2.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">toHaveBeenCalledWith: </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">toHaveBeenCalledWith</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is a Jasmine matcher that checks if a spy (mocked function) was called with the expected arguments. </span> </p>"
                },
                {
                    "text": "<p><strong>How does </strong><strong style=\"color: rgb(0, 138, 0);\">async </strong><strong>work in Angular testing?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 18,
                    "description": "<p><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">async</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">utility (renamed to </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">waitForAsync</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">) tracks all </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">pending async tasks</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> (Promises, timers, XHR) and waits until they are finished. Only then allows the test to continue and run expectations. It waits for </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">real async operations</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to finish automatically.</span></p></br><pre data-language=\"plain\">\n\nmy.component.ts\n\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n@Component({\n  selector: &#39;app-my&#39;,\n  template: `&lt;div *ngIf=&quot;data&quot;&gt;{{ data }}&lt;/div&gt;`\n})\nexport class MyComponent implements OnInit {\n  data: string | null = null;\n  ngOnInit(): void {\n    // Simulate async data (like HTTP call)\n    this.loadData().then(result =&gt; {\n      this.data = result;\n    });\n  }\n  loadData(): Promise&lt;string&gt; {\n    return new Promise(resolve =&gt; {\n      setTimeout(() =&gt; resolve(&#39;Hello Async Data!&#39;), 500);\n    });\n  }\n}\n</pre></br><pre data-language=\"plain\">\n\n// my.component.spec.ts\n\nit(&#39;should load data async and render it&#39;, waitForAsync(() =&gt; {\n fixture.detectChanges(); // triggers ngOnInit\n fixture.whenStable().then(() =&gt; {\n fixture.detectChanges(); // update view after async resolves\n const div = fixture.debugElement.query(By.css(&#39;div&#39;)).nativeElement;\n expect(div.textContent).toContain(&#39;Hello Async Data!&#39;);\n expect(component.data).toBe(&#39;Hello Async Data!&#39;);\n });\n</pre></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">ðŸ”‘</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> What happens here:</strong></p></br><p><strong>1.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.detectChanges():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> triggers </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, which starts an async task.</span></p></br><p><strong>2.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.whenStable():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> waits until </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">all Promises &amp; async tasks are finished</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><strong>3.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.detectChanges():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> refreshes template after data is set.</span></p></br><p><strong>4.</strong> <span style=\"color: rgb(0, 0, 0); background-color: transparent;\">Test asserts that </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">async data is rendered</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">Explain:</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </span></p><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">I created a </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">loadData</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function that returns a Promise and resolved this Promise inside </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, storing the result in a </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">data</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> property.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">For the unit test: I created a </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">loadData</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function which returns a Promise and resolved this Promise in </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, then stored the result in the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">data</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">property. I wrote a unit test case for this. I used </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">TestBed.createComponent</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to create a fixture for the component, which provides the setup before running the tests, and I accessed the component instance using </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.componentInstance</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">Inside the </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">it</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> block for </span><em style=\"color: rgb(0, 0, 0); background-color: transparent;\">&#39;should load data async and render it&#39;</em><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, I wrapped the test with the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">waitForAsync</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function. First, I ran</span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.detectChanges()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to update the view. Then I used </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.whenStable()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to wait until the component became stable. After that, I got the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">div</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">elementâ€™s </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">nativeElement</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">using </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.debugElement.query(By.css(&#39;div&#39;)).nativeElement</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">. Finally, I compared </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">div.textContent</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> and </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">component.data</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> with</span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">&#39;Hello Async Data&#39;</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p>"
                },
                {
                    "text": "<p><strong>How does </strong><strong style=\"color: rgb(0, 138, 0);\">fakeAsync </strong><strong>work in Angular testing?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 19,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">utility tests asynchronous code </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">synchronously</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> by simulating the passage of time.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">When you wrap a test function in </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, Angular runs it and replaces real async functions </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">(</strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">Promise.then</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, RxJS timers, etc.) with </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">mocked versions</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><pre data-language=\"plain\">\n\nfake-async.component.ts\n\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n@Component({\n  selector: &#39;app-fake-async&#39;,\n  template: `\n    &lt;div&gt;Static Div&lt;/div&gt;\n    &lt;div *ngIf=&quot;data&quot;&gt;{{ data }}&lt;/div&gt;\n    &lt;div&gt;Another Div&lt;/div&gt;\n  `\n})\nexport class FakeAsyncComponent implements OnInit {\n  data: string | null = null;\n  ngOnInit(): void {\n    setTimeout(() =&gt; {\n      this.data = &#39;Hello FakeAsync!&#39;;\n    }, 1000);\n  }\n}\n</pre></br><pre data-language=\"plain\">\n\nit(&#39;should load async data into the second div&#39;, fakeAsync(() =&gt; {\n    fixture.detectChanges(); // triggers ngOnInit\n    expect(component.data).toBeNull();\n    tick(1000);              // simulate passage of 1 second\n    fixture.detectChanges();\n    const divs = fixture.debugElement.queryAll(By.css(&#39;div&#39;));\n    expect(divs.length).toBe(3);\n    // Second div contains async data\n    expect(divs[1].nativeElement.textContent).toContain(&#39;Hello FakeAsync!&#39;);\n    expect(component.data).toBe(&#39;Hello FakeAsync!&#39;);\n  }));\n</pre></br><p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Note:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> Donâ€™t use fixture.detectChanges(); in beforeEach() otherwise we will get an error.</span></p>"
                },
                {
                    "text": "<p><strong>What is the difference between</strong><strong style=\"color: rgb(0, 138, 0);\"> tick()</strong><strong> and </strong><strong style=\"color: rgb(0, 138, 0);\">flush()</strong><strong> in Angular tests?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 20,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Both </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">tick()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> and </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">flush()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> are used </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">inside </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> tests</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> to control virtual time and execute async tasks.</span></p></br><p><strong>1.</strong>  <strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">tick()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a helper function that works only inside a </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> zone</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. It </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">simulates the passage of virtual time</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, allowing scheduled async tasks </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">(</strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, RxJS timers, Promises, etc.) to be executed </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">without waiting in real time</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>2.</strong>  <strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">flush()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a helper function that works only inside a </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">zone. It executes all pending timers at once, without needing any arguments, and moves the virtual clock forward until all queued timers (macroTasks like </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">and </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">) are executed.</span></p>"
                },
                {
                    "text": "<p><strong>How can you test an Angular service that makes HTTP calls?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 21,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">When a service uses HttpClient, we donâ€™t hit the real backend in unit tests. Instead, we use Angularâ€™s HttpClientTestingModule and HttpTestingController to mock HTTP requests.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">I test Angular services with HTTP calls by using HttpClientTestingModule and HttpTestingController. This allows me to mock requests, assert on the method/URL, and return mock responses with flush() instead of calling the real backend.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Call </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">httpMock.verify()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> in </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">afterEach</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">to ensure no unmatched requests.</span></p></br><pre data-language=\"plain\">\n\nTest service file\n\nimport { TestBed } from &#39;@angular/core/testing&#39;;\nimport { User } from &#39;./user&#39;;\nimport { HttpTestingController, provideHttpClientTesting } from &#39;@angular/common/http/testing&#39;;\nimport { provideHttpClient, withFetch } from &#39;@angular/common/http&#39;;\ndescribe(&#39;User&#39;, () =&gt; {\n  let service: User;\n  let httpMock: HttpTestingController;\n  beforeEach(() =&gt; {\n    TestBed.configureTestingModule({\n      providers: [\n        User,\n        provideHttpClient(withFetch()),\n        provideHttpClientTesting()\n      ]\n    });\n    service = TestBed.inject(User);\n    httpMock = TestBed.inject(HttpTestingController);\n  });\n  afterEach(() =&gt; {\n    httpMock.verify();\n  })\n  it(&#39;should be created&#39;, () =&gt; {\n    expect(service).toBeTruthy();\n  });\n  it(&#39;should fetch users from API&#39;, () =&gt; {\n    const mockUsers = [\n      {\n        &quot;userId&quot;: 1,\n        &quot;id&quot;: 1,\n        &quot;title&quot;: &quot;delectus aut autem&quot;,\n        &quot;completed&quot;: false\n      }];\n      \n    service.getUsers().subscribe(users =&gt; {\n      expect(mockUsers).toEqual(users);\n    });\n    const req = httpMock.expectOne(&#39;https://jsonplaceholder.typicode.com/todos/1&#39;);\n    expect(req.request.method).toBe(&#39;GET&#39;);\n    req.flush(mockUsers);\n  });\n});\n\n</pre>"
                },
                {
                    "text": "<p><strong>How do you test an Angular component with </strong><strong style=\"color: rgb(0, 138, 0);\">@Input()</strong><strong> and </strong><strong style=\"color: rgb(0, 138, 0);\">@Output()</strong><strong> properties?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 22,
                    "description": ""
                },
                {
                    "text": "<p><strong>What is </strong><strong style=\"color: rgb(0, 138, 0);\">ComponentFixture</strong><strong> in Angular testing, and why is it used?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 23,
                    "description": ""
                },
                {
                    "text": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">What is the use of </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">spyOn()</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> in Jasmine?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 24,
                    "description": "<p><code>spyOn</code> is a <strong>Jasmine function</strong> used in Angular unit tests.</p></br><p>It <strong>spies on methods</strong> of components, services, or other objects.</p></br><p>It allows you to <strong>track method calls</strong> and <strong>mock return values</strong> without executing the real implementation.</p>"
                },
                {
                    "text": "<p><strong>What is the use of createSpyObject() in Jasmine?</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 25,
                    "description": ""
                },
                {
                    "text": "<p><strong>Explain Jasmine </strong><strong style=\"color: rgb(0, 138, 0);\">spyOn </strong><strong>and </strong><strong style=\"color: rgb(0, 138, 0);\">createSpyObj </strong><strong>in Angular Unit Testing.</strong></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "Angular",
                    "topicId": 26,
                    "description": "<p><code>spyOn</code> is used to watch or mock methods of an existing object. It helps us test without calling the real implementation. For example, <code>spyOn(service, &#39;getData&#39;).and.returnValue(mockData)</code>.</p></br><p><code>createSpyObj</code> is used when we want to mock an entire dependency or service. Instead of creating real objects, we create a fake one with multiple spy methods, like <code>jasmine.createSpyObj(&#39;UserService&#39;, [&#39;getUser&#39;, &#39;saveUser&#39;])</code>.</p></br><p>The key difference is: <code>spyOn</code> works on existing objects, while <code>createSpyObj</code> creates a new fake object.</p>"
                }
            ],
            "subSections": []
        }
    ];
} 