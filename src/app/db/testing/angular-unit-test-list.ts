export const angularUnitTestList = () => {
    return [
        {
            "name": "<p><strong>Basic</strong></p>",
            "sectionId": 24,
            "noteType": "AngularUnitTest",
            "topics": [
                {
                    "text": "<p>What is Unit Testing in Angular, and why is it important?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 7,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Unit testing in Angular is the process of testing individual components, services, or functions in isolation to ensure they work correctly and make the application more reliable and maintainable.</span></p>"
                },
                {
                    "text": "<p>What testing frameworks are commonly used with Angular (Jasmine, Karma, Jest)?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 8,
                    "description": "<p class=\"ql-align-justify\"><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jasmine</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a testing framework, </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Karma</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a test runner (executes tests in browsers), and </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jest</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is an alternative framework+runner offering faster, simpler testing.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">In short: </span><em style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jasmine + Karma work together</em><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, while </span><em style=\"background-color: transparent; color: rgb(0, 0, 0);\">Jest alone can replace both</em><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>Jasmine: Jasmine</strong> is an <strong>open-source JavaScript testing framework</strong>.</p><p>A <strong>JavaScript testing framework</strong> provides the <strong>building blocks</strong> to write <strong>JavaScript unit test cases</strong>, ensuring that each <strong>line of code</strong> is properly <strong>unit tested</strong>.</p><p>It is used to <strong>test any type of JavaScript application</strong>.</p></br><p><strong>Karma:</strong> <strong>Karma</strong> is a <strong>testing automation tool</strong> created by the <strong>AngularJS team</strong>.</p><p><strong>Karma</strong> is an <strong>open-source tool</strong>.</p><p><strong>Karma allows us to execute test cases</strong> on <strong>any browser</strong>.</p>"
                },
                {
                    "text": "<p>What is the difference between unit testing and end-to-end testing?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngAngularUnitTestular",
                    "topicId": 9,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Unit testing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> checks individual components/services in isolation, while </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">end-to-end testing</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> validates the entire application flow from the user‚Äôs perspective.</span></p>"
                },
                {
                    "text": "<p>What is the default test runner in Angular projects created with Angular CLI?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 10,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">The default test runner in Angular projects created with Angular CLI is </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Karma</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p>"
                },
                {
                    "text": "<p>How do you create a new Angular component test file using CLI?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 11,
                    "description": "<p class=\"ql-align-justify\"><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">You can create a new Angular component with its spec (test) file using:</span></p><pre data-language=\"plain\">\nng generate component component-name\n</pre><p class=\"ql-align-justify\"></p><p class=\"ql-align-justify\"><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">üëâ The CLI automatically generates the </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">.spec.ts</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> test file.</span></p></br>"
                },
                {
                    "text": "<p>What is ‚Äòdescribe‚Äô in jasmine in Unit Testing?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 12,
                    "description": "<p><strong>&#39;describe&#39;</strong> is a <strong>test suite</strong> (a <strong>folder</strong> or <strong>box</strong>) in <strong>Jasmine</strong>. It <strong>groups together related test cases</strong> (<strong>it blocks</strong>) and helps <strong>organize tests logically</strong>.</p>"
                },
                {
                    "text": "<p>What is beforeEach in Jasmine?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 13,
                    "description": "<p><strong>beforeEach</strong> is a <strong>special function</strong> provided by <strong>Jasmine</strong> (and <strong>Jest</strong>, <strong>Mocha</strong>, etc.). It <strong>runs before every</strong> <strong>‚Äòit‚Äô block</strong> (<strong>spec/test case</strong>) inside a <strong>describe block</strong>. It‚Äôs used to <strong>set up common code</strong> needed by <strong>multiple tests</strong>.</p>"
                },
                {
                    "text": "<p>What is TestBed in Angular Unit Testing?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 14,
                    "description": "<p><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">TestBed</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">is the </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">primary Angular testing utility</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> that creates a </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">simulated Angular environment</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> for unit testing.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">It allows us to test components, directives, pipes, and services </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">with Angular‚Äôs dependency injection, change detection, and templates</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p class=\"ql-align-justify\"><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">1. </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">TestBed </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">Configures a testing module</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> (like a mini </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">NgModule</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">):</span></p><pre data-language=\"plain\">\n\n  TestBed.configureTestingModule({\n  \tdeclarations: [MyComponent],\n  \tproviders: [MyService],\n \timports: [FormsModule, HttpClientTestingModule]\n   });\n</pre><p class=\"ql-align-justify\"></p><p class=\"ql-align-justify\"><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">2.</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> TestBed creates Components for testing:</span></p><pre data-language=\"plain\">\n\n   const fixture = TestBed.createComponent(MyComponent);\n   const component = fixture.componentInstance;\n   fixture.detectChanges(); // runs ngOnInit + bindings\n</pre></br><p>3. TestBed is used to Inject Services:</p><pre data-language=\"plain\">\n      \n    const service = TestBed.inject(MyService);\n\n</pre><p><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">4. Run Change Detection:</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> Updates the DOM after changing component properties.</span></p>"
                },
                {
                    "text": "<p>What is ‚Äòit‚Äô in jasmine in Unit Testing?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 15,
                    "description": "<p><strong>‚Äòit‚Äô</strong> defines a <strong>test case</strong>. It takes a <strong>description string</strong> that states the <strong>expected behavior</strong>, and a <strong>function</strong> that contains the <strong>test logic</strong> with <strong>expect</strong>.</p>"
                },
                {
                    "text": "<p>What is ‚Äòexpect‚Äô in Jasmin?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 16,
                    "description": "<p>In <strong>Angular unit testing</strong>, the <strong>expect</strong> function <strong>verifies</strong> that the <strong>actual result</strong> matches the <strong>expected result</strong> using <strong>matchers</strong>.</p>"
                },
                {
                    "text": "<p>Can you describe some matchers?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 17,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">In Angular unit testing, a matcher function compares the actual result with the expected result.</span></p></br><p><strong>1.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">toBeTruthy:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">.toBeTruthy()</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">checks that a value is not </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">false</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">0</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">&#39;&#39;</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">null</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">undefined</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, or </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">NaN</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>2.</strong> <strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">toHaveBeenCalledWith: </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">toHaveBeenCalledWith</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">is a Jasmine matcher that checks if a spy (mocked function) was called with the expected arguments. </span> </p>"
                },
                {
                    "text": "<p>How does <span style=\"color: rgb(0, 138, 0);\">async </span>work in Angular testing?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 18,
                    "description": "<p><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">async</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">utility (renamed to </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">waitForAsync</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">) tracks all </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">pending async tasks</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> (Promises, timers, XHR) and waits until they are finished. Only then allows the test to continue and run expectations. It waits for </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">real async operations</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to finish automatically.</span></p></br><pre data-language=\"plain\">\n\nmy.component.ts\n\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n@Component({\n  selector: &#39;app-my&#39;,\n  template: `&lt;div *ngIf=&quot;data&quot;&gt;{{ data }}&lt;/div&gt;`\n})\nexport class MyComponent implements OnInit {\n  data: string | null = null;\n  ngOnInit(): void {\n    // Simulate async data (like HTTP call)\n    this.loadData().then(result =&gt; {\n      this.data = result;\n    });\n  }\n  loadData(): Promise&lt;string&gt; {\n    return new Promise(resolve =&gt; {\n      setTimeout(() =&gt; resolve(&#39;Hello Async Data!&#39;), 500);\n    });\n  }\n}\n</pre></br><pre data-language=\"plain\">\n\n// my.component.spec.ts\n\nit(&#39;should load data async and render it&#39;, waitForAsync(() =&gt; {\n fixture.detectChanges(); // triggers ngOnInit\n fixture.whenStable().then(() =&gt; {\n fixture.detectChanges(); // update view after async resolves\n const div = fixture.debugElement.query(By.css(&#39;div&#39;)).nativeElement;\n expect(div.textContent).toContain(&#39;Hello Async Data!&#39;);\n expect(component.data).toBe(&#39;Hello Async Data!&#39;);\n });\n</pre></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">üîë</span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> What happens here:</strong></p></br><p><strong>1.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.detectChanges():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> triggers </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, which starts an async task.</span></p></br><p><strong>2.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.whenStable():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> waits until </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">all Promises &amp; async tasks are finished</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><strong>3.</strong> <strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">fixture.detectChanges():</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> refreshes template after data is set.</span></p></br><p><strong>4.</strong> <span style=\"color: rgb(0, 0, 0); background-color: transparent;\">Test asserts that </span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">async data is rendered</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\">Explain:</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </span></p><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">I created a </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">loadData</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function that returns a Promise and resolved this Promise inside </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, storing the result in a </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">data</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> property.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">For the unit test: I created a </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">loadData</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function which returns a Promise and resolved this Promise in </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">ngOnInit()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, then stored the result in the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">data</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">property. I wrote a unit test case for this. I used </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">TestBed.createComponent</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to create a fixture for the component, which provides the setup before running the tests, and I accessed the component instance using </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.componentInstance</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p></br><p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">Inside the </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">it</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> block for </span><em style=\"color: rgb(0, 0, 0); background-color: transparent;\">&#39;should load data async and render it&#39;</em><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">, I wrapped the test with the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">waitForAsync</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">function. First, I ran</span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.detectChanges()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to update the view. Then I used </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.whenStable()</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> to wait until the component became stable. After that, I got the </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">div</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">element‚Äôs </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">nativeElement</strong><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">using </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">fixture.debugElement.query(By.css(&#39;div&#39;)).nativeElement</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">. Finally, I compared </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">div.textContent</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> and </span><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">component.data</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> with</span><strong style=\"color: rgb(0, 0, 0); background-color: transparent;\"> </strong><strong style=\"color: rgb(24, 128, 56); background-color: transparent;\">&#39;Hello Async Data&#39;</strong><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">.</span></p>"
                },
                {
                    "text": "<p>How does <span style=\"color: rgb(0, 138, 0);\">fakeAsync </span>work in Angular testing?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 19,
                    "description": "<p><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">utility tests asynchronous code </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">synchronously</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> by simulating the passage of time.</span></p></br><p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">When you wrap a test function in </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, Angular runs it and replaces real async functions </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">(</strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">Promise.then</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, RxJS timers, etc.) with </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">mocked versions</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><pre data-language=\"plain\">\n\nfake-async.component.ts\n\nimport { Component, OnInit } from &#39;@angular/core&#39;;\n@Component({\n  selector: &#39;app-fake-async&#39;,\n  template: `\n    &lt;div&gt;Static Div&lt;/div&gt;\n    &lt;div *ngIf=&quot;data&quot;&gt;{{ data }}&lt;/div&gt;\n    &lt;div&gt;Another Div&lt;/div&gt;\n  `\n})\nexport class FakeAsyncComponent implements OnInit {\n  data: string | null = null;\n  ngOnInit(): void {\n    setTimeout(() =&gt; {\n      this.data = &#39;Hello FakeAsync!&#39;;\n    }, 1000);\n  }\n}\n</pre></br><pre data-language=\"plain\">\n\nit(&#39;should load async data into the second div&#39;, fakeAsync(() =&gt; {\n    fixture.detectChanges(); // triggers ngOnInit\n    expect(component.data).toBeNull();\n    tick(1000);              // simulate passage of 1 second\n    fixture.detectChanges();\n    const divs = fixture.debugElement.queryAll(By.css(&#39;div&#39;));\n    expect(divs.length).toBe(3);\n    // Second div contains async data\n    expect(divs[1].nativeElement.textContent).toContain(&#39;Hello FakeAsync!&#39;);\n    expect(component.data).toBe(&#39;Hello FakeAsync!&#39;);\n  }));\n</pre></br><p><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">Note:</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> Don‚Äôt use fixture.detectChanges(); in beforeEach() otherwise we will get an error.</span></p>"
                },
                {
                    "text": "<p>What is the difference between<span style=\"color: rgb(0, 138, 0);\"> tick()</span> and <span style=\"color: rgb(0, 138, 0);\">flush()</span> in Angular tests?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 20,
                    "description": "<p><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">Both </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">tick()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> and </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">flush()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> are used </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">inside </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> tests</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> to control virtual time and execute async tasks.</span></p></br><p><strong>1.</strong>  <strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">tick()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a helper function that works only inside a </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> zone</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">. It </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">simulates the passage of virtual time</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, allowing scheduled async tasks </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">(</strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">, </strong><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">, RxJS timers, Promises, etc.) to be executed </span><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\">without waiting in real time</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">.</span></p></br><p><strong>2.</strong>  <strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">flush()</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\"> is a helper function that works only inside a </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">fakeAsync</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">zone. It executes all pending timers at once, without needing any arguments, and moves the virtual clock forward until all queued timers (macroTasks like </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setTimeout</strong><strong style=\"background-color: transparent; color: rgb(0, 0, 0);\"> </strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">and </span><strong style=\"background-color: transparent; color: rgb(24, 128, 56);\">setInterval</strong><span style=\"background-color: transparent; color: rgb(0, 0, 0);\">) are executed.</span></p>"
                },
                {
                    "text": "<p>What is <span style=\"color: rgb(0, 138, 0);\">ComponentFixture</span> in Angular testing, and why is it used?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 23,
                    "description": "<p><strong>ComponentFixture</strong> allows us to:</p><ul><li><strong>Access the component instance</strong></li><li><strong>Access the native DOM element</strong> using <code><strong>fixture.nativeElement</strong></code> for <strong>DOM testing</strong></li><li><strong>Trigger change detection</strong> using <code><strong>fixture.detectChanges()</strong></code></li></ul></br>"
                },
                {
                    "text": "<p><span style=\"color: rgb(0, 0, 0); background-color: transparent;\">What is the use of </span><span style=\"color: rgb(24, 128, 56); background-color: transparent;\">spyOn()</span><span style=\"color: rgb(0, 0, 0); background-color: transparent;\"> in Jasmine?</span></p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 24,
                    "description": "<p><code><strong>spyOn()</strong></code> is used to <strong>spy on an existing method</strong> of a <strong>real object or service</strong>.</p><p>It tracks calls, arguments, and return values ‚Äî and optionally allows you to mock its behavior.</p></br><p><strong>getSum method is called from component&#39;s ngOnInit with parameters:</strong></p><pre data-language=\"plain\">\n  it(&#39;should call getSum method from UserService&#39;, () =&gt; {\n    const userService = TestBed.inject(UserService);\n    const spy = spyOn(userService, &#39;getSum&#39;).and.callThrough();\n    component.ngOnInit();\n    expect(spy).toHaveBeenCalledOnceWith(5, 7);\n  });\n</pre></br><p><strong>getSum method is called from component&#39;s ngOnInit without parameters:</strong></p><pre data-language=\"plain\">\n it(&#39;should call getSum method from UserService&#39;, () =&gt; {\n    const userService = TestBed.inject(UserService);\n    const spy = spyOn(userService, &#39;getSum&#39;).and.callThrough();\n    component.ngOnInit();\n    expect(spy).toHaveBeenCalled();\n  });\n</pre></br><p><strong>getSum method is called from component&#39;s ngOnInit and return value 7:</strong></p><pre data-language=\"plain\">\nit(&#39;should set sum with the value returned from getSum&#39;, () =&gt; {\n    spyOn(userService, &#39;getSum&#39;).and.returnValue(7);\n    fixture.detectChanges(); // triggers ngOnInit()\n    expect(component.sum).toBe(7);\n  });\n</pre></br><p>‚úÖ <strong>Key Points:</strong></p><ul><li>Works on <strong>existing objects</strong>.</li><li>Replaces only the <strong>specific method</strong> you spy on.</li><li>You can <strong>mock return values</strong> or <strong>verify calls</strong>.</li></ul></br><p><strong>‚ÄúUsed to spy‚Äù</strong> means <strong>to watch, track, or monitor a function‚Äôs behavior</strong> during a test ‚Äî <strong>without actually running its real implementation</strong></p>"
                },
                {
                    "text": "<p>What is the use of createSpyObject() in Jasmine?</p>",
                    "sectionId": 24,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 25,
                    "description": "<p><code><strong>createSpyObject()</strong></code> is used to <strong>create a completely fake object</strong> with one or more <strong>spy methods</strong> ‚Äî without needing a real class or instance.</p></br><pre data-language=\"plain\">\nit(&#39;should call save method of mock service&#39;, () =&gt; {\n  const mockService = jasmine.createSpyObj(&#39;UserService&#39;, [&#39;save&#39;]);\n  mockService.save.and.returnValue(of(true));\n\n  component = new UserComponent(mockService);\n  component.saveUser();\n\n  expect(mockService.save).toHaveBeenCalled();\n});\n</pre></br><p>‚úÖ <strong>Key Points:</strong></p><ul><li>Creates a <strong>mock object from scratch</strong>.</li><li>Ideal when you want <strong>complete control</strong> over dependencies.</li><li>Doesn‚Äôt require the <strong>real class</strong> or <strong>Angular TestBed</strong>.</li></ul></br>"
                }
            ],
            "subSections": []
        },
        {
            "name": "<p><strong>Scenario Based Questions</strong></p>",
            "sectionId": 60,
            "noteType": "AngularUnitTest",
            "topics": [
                {
                    "text": "<p>How do we verify that a component is created?</p>",
                    "sectionId": 60,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 286,
                    "description": "<p>First, I configure the testing module in <code>beforeEach</code> using <code>TestBed.configureTestingModule({...})</code>. It allows us to create a test environment that simulates an Angular module.</p></br><p> <code>beforeEach</code> is a Jasmine function that runs before each individual test case.</p><p>Then, I create a fixture using <code>TestBed.createComponent(App)</code>. The fixture allows us to access the component instance, access the native DOM element, and trigger change detection.</p></br><p>We can get the component instance using <code>fixture.componentInstance</code>.</p><p>Next, I write the test case inside the <code>it</code> block. The <code>it</code> function takes a description string and a function that contains the test logic.</p></br><p>To test whether the component is created successfully, we pass the component instance into <code>expect()</code> and verify it using the matcher <code>toBeTruthy()</code>.</p><p>So, we use <code>expect(app).toBeTruthy()</code> to confirm that the component is created.</p></br><pre data-language=\"plain\">\n// ts file\n\nimport { Component } from &#39;@angular/core&#39;;\n\n@Component({\n  selector: &#39;app-root&#39;,\n  imports: [],\n  template: `&lt;h1&gt;{{title()}}&lt;/h1&gt;`,\n  styleUrl: &#39;./app.scss&#39;\n})\nexport class App {\n}\n</pre></br><pre data-language=\"plain\">\n// testing file\n\nimport { TestBed } from &#39;@angular/core/testing&#39;;\nimport { App } from &#39;./app&#39;;\n\ndescribe(&#39;App&#39;, () =&gt; {\n  beforeEach(async () =&gt; {\n    await TestBed.configureTestingModule({\n      imports: [App],\n    }).compileComponents();\n  });\n\n  it(&#39;should create the app&#39;, () =&gt; {\n    const fixture = TestBed.createComponent(App);\n    const app = fixture.componentInstance;\n    expect(app).toBeTruthy();\n  });\n});\n</pre></br>"
                },
                {
                    "text": "<p>Suppose you have a parent component passing a value to a child component via <code>@Input()</code>. How would you write a unit test to verify that the child receives the correct value?</p>",
                    "sectionId": 60,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 261,
                    "description": "<p>Here I will write a unit test in the parent component and describe the fixture and component for <code>ParentComponent</code> using <code>TestBed.createComponent(Parent)</code> for the fixture and <code>fixture.componentInstance</code> for the component instance.</p></br><p>Then I will access the child component instance using <code>fixture.debugElement.query</code> and pass <code>By.directive</code> with <code>ChildComponent</code>. This gives the child component instance.</p></br><p>Now I will change the property value with mock data, like <code>component.name = &#39;Vivek&#39;</code>, then run <code>fixture.detectChanges();</code> to update the value, and finally check if the expected value is the same as the mock value using <code>expect(childComponent.userName).toBe(&#39;Vivek&#39;)</code>.</p></br><p>Link: <a href=\"https://github.com/777Vikki/Angular-Unit-Testing/blob/1-input-communication/src/app/parent/parent.spec.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/Angular-Unit-Testing/blob/1-input-communication/src/app/parent/parent.spec.ts</a></p>"
                },
                {
                    "text": "<p>If a service method is called from a component, how many ways can we mock the service in unit testing?</p>",
                    "sectionId": 60,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 294,
                    "description": "<p>üß©<strong> 1. Using jasmine.createSpyObj() (Most Common):</strong></p><p><code style=\"background-color: rgb(236, 236, 236); color: rgb(0, 0, 0);\"><strong>createSpyObject()</strong></code><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> is used to </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">create a completely fake object</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> with one or more </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">spy methods</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> ‚Äî without needing a real class or instance.</span></p></br><p>üß± <strong>2. Using a Fake (Custom Class Mock):</strong></p><p>Manually create a fake version of the service.</p></br><pre data-language=\"plain\">\nclass FakeMyService {\n  getData() {\n    return &#39;Fake Data&#39;;\n  }\n}\nproviders: [{ provide: MyService, useClass: FakeMyService }];\n</pre></br><p>‚öôÔ∏è <strong>3. Using useValue with Inline Object:</strong></p><p>Provide a mock object directly.</p><pre data-language=\"plain\">\nproviders: [\n  { provide: MyService, useValue: { getData: () =&gt; &#39;Inline Mock Data&#39; } }\n]\n</pre></br><p>üß™ <strong>4. Using </strong><code><strong>spyOn()</strong></code><strong> on Real Instance:</strong></p><p><code style=\"background-color: rgb(236, 236, 236); color: rgb(0, 0, 0);\"><strong>spyOn()</strong></code><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> is used to </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">spy on an existing method</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\"> of a </span><strong style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">real object or service</strong><span style=\"background-color: rgb(255, 255, 255); color: rgb(0, 0, 0);\">.</span></p><p><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">It tracks calls, arguments, and return values ‚Äî and optionally allows you to mock its behavior.</span></p></br><p>üåê <strong>5. Using </strong><code><strong>HttpTestingController</strong></code><strong> (for HTTP-based Services):</strong></p><p>Mock HTTP requests instead of the service itself.</p></br>"
                },
                {
                    "text": "<p>How do you test a service call inside a component in Angular?</p>",
                    "sectionId": 60,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 262,
                    "description": "<p><strong>spyOn</strong>:</p><p><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\">Here I will describe the fixture and component for </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">Current Component</code><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\"> using </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">TestBed.createComponent(Parent)</code><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\"> for the fixture and </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">fixture.componentInstance</code><span style=\"color: rgb(0, 0, 0); background-color: rgb(255, 255, 255);\"> for the component instance. Then I inject service to pass service into </span><code style=\"color: rgb(0, 0, 0); background-color: rgb(236, 236, 236);\">TestBed.inject()</code>.</p></br><p>We mock the service method using <code style=\"background-color: rgb(236, 236, 236); color: rgb(0, 0, 0);\">spyOn()</code> so no real API is called.</p><p>Then we trigger the component function that uses the service.</p><p>If the service is called with a single parameter, then I will check using:</p><p><code> expect(userService.getUserDetail).toHaveBeenCalledWith(1);</code></p><p>If the service is called with multiple parameters, then I will check using:</p><p><code> expect(userService.multiplyTwoNumber).toHaveBeenCalledWith(5, 13);</code></p></br><p>Link: <a href=\"https://github.com/777Vikki/Angular-Unit-Testing/blob/2-call-service-from-component-spyOn/src/app/app.spec.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/Angular-Unit-Testing/blob/2-call-service-from-component-spyOn/src/app/app.spec.ts</a></p></br><p><strong>createSpyObj</strong>:</p><p><a href=\"https://github.com/777Vikki/Angular-Unit-Testing/blob/3-call-service-from-component-createSpyObj/src/app/app.spec.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/Angular-Unit-Testing/blob/3-call-service-from-component-createSpyObj/src/app/app.spec.ts</a></p>"
                },
                {
                    "text": "<p>Suppose your service calls an API using <code>HttpClient.get()</code>. How would you write a test for it using <code>HttpTestingController</code>?</p>",
                    "sectionId": 60,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 295,
                    "description": "<p>When testing HTTP-based services, we use <code>HttpTestingController</code> from <code>HttpClientTestingModule</code> to intercept and mock HTTP requests. It allows us to test the service logic without making real API calls. We verify requests using <code>expectOne()</code>, provide mock data using <code>flush()</code>, and ensure no pending requests remain using <code>verify()</code>.</p></br><p>Link: <a href=\"https://github.com/777Vikki/Angular-Unit-Testing/blob/4-verify-http-in-service/src/app/user-service.spec.ts\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/777Vikki/Angular-Unit-Testing/blob/4-verify-http-in-service/src/app/user-service.spec.ts</a></p>"
                },
                {
                    "text": "<p>How do you simulate a click event in Angular unit tests?</p>",
                    "sectionId": 60,
                    "subSectionId": -1,
                    "noteType": "AngularUnitTest",
                    "topicId": 352,
                    "description": "<p><strong>‚úÖ 1. Using By.css(&#39;#getUserDetailBtn&#39;):</strong></p><pre data-language=\"plain\">\nimport { By } from &quot;@angular/platform-browser&quot;\n\nit(&#39;should call getUserDetail when button is clicked&#39;, () =&gt; {\n  const spy = spyOn(component, &#39;getUserDetail&#39;);\n\n  const btn = fixture.debugElement.query(By.css(&#39;#getUserDetailBtn&#39;));\n  btn.triggerEventHandler(&#39;click&#39;, null);\n\n  expect(spy).toHaveBeenCalled();\n});\n</pre></br><p><code>fixture.debugElement.query(By.css(&#39;#getUserDetailBtn&#39;))</code> is used to <strong>find an element from the component‚Äôs template during unit testing</strong>.</p></br><p><strong>‚úÖ 2. Using nativeElement (not recommended but valid):</strong></p><pre data-language=\"plain\">\nit(&#39;should call getUserDetail when button clicked&#39;, () =&gt; {\n  const spy = spyOn(component, &#39;getUserDetail&#39;);\n\n  const btn: HTMLButtonElement =\n    fixture.nativeElement.querySelector(&#39;#getUserDetailBtn&#39;);\n  btn.click();\n\n  expect(spy).toHaveBeenCalled();\n});\n</pre></br><p><strong>Note:</strong> Use <code>By.css()</code> because it works consistently with Angular‚Äôs change detection and DebugElement.</p>"
                }
            ],
            "subSections": []
        }
    ];
}